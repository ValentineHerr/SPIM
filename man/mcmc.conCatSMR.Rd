% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc.conCatSMR.R
\name{mcmc.conCatSMR}
\alias{mcmc.conCatSMR}
\title{Fit the conventional (marking process not modeled) categorical spatial mark resight model when number of marked
individuals is known}
\usage{
mcmc.conCatSMR(data, niter = 2400, nburn = 1200, nthin = 5,
  M = 200, inits = NA, obstype = "poisson", nswap = NA,
  proppars = list(lam0 = 0.05, sigma = 0.1, s = 0.2, st = 0.2),
  storeLatent = TRUE, storeGamma = TRUE, IDup = "Gibbs", tf = NA,
  priors = NA)
}
\arguments{
\item{data}{a data list as formatted by sim.conCatSMR(). See description for more details.}

\item{niter}{the number of MCMC iterations to perform}

\item{nburn}{the number of MCMC iterations to discard as burnin}

\item{nthin}{the MCMC thinning interval. Keep every nthin iterations.}

\item{M}{the level of data augmentation}

\item{inits}{a list of initial values for lam0, sigma, gamma, and psi. The list element for 
gamma is itself a list with ncat elements. See the example below.}

\item{obstype}{a character string indicating the observation model, "bernoulli" or "poisson".}

\item{nswap}{an integer indicating how many samples for which the latent identities
are updated on each iteration.}

\item{storeLatent}{a logical indicator for whether or not the posteriors of the latent individual identities, z, and s are
stored and returned}

\item{storeGamma}{a logical indicator for whether or not the posteriors for gamma are stored and returned}

\item{IDup}{a character string indicating whether the latent identity update is done by Gibbs or Metropolis-
Hastings, "Gibbs", or "MH". For obstype="bernoulli", only "MH" is available because the full conditional is not known.}

\item{propars}{a list of proposal distribution tuning parameters for lam0, sigma, s, and st, for the
the activity centers of untelemetered and telemetered individuals, respectively. The tuning parameter
should be smaller for individuals with telemetry and increasingly so as the number of locations per
individual increases}
}
\description{
This function fits the conventional categorical spatial mark resight model when the number of
marked individuals is known.The distribution of marked individuals across the landscape is assumed to be
spatially uniform. This can be relaxed by modeling the marking process in the generalized spatial mark resight
samplers. An extension of this sampler that allows detection function parameters to vary by the
levels of one categorical covariate is located in mcmc.conCatSMR.df(). A version of this sampler
for an unknown number of marked individuals is in mcmc.conCatSMR.natural().

the data list should be formatted to match the list outputted by sim.conCatSMR(), but not all elements
of that object are necessary. y.sight.marked, y.sight.unmarked, G.marked, and G.unmarked are necessary
list elements. y.sight.x and G.x for x=unk and marke.noID are necessary if there are samples
of unknown marked status or samples from marked samples without individual identities.

An element "X", a matrix of trap coordinates, an element "K", the integer number of occasions, and
an element n.marked, the integer number of marked individuals are necessary.

IDlist is a list containing elements ncat and IDcovs. ncat is an integer for the number
of categorical identity covariates and IDcovs is a list of length ncat with elements containing the
values each categorical identity covariate may take.

An element "locs", an n.marked x nloc x  2 array of telemetry locations is optional. This array can
have missing values if not all individuals have the same number of locations and the entry for individuals
with no telemetry should all be missing values (coded NA).

I will write a function to build the data object with "secr-like" input in the near future.
}
\examples{
\dontrun{
library(coda)
N=50
n.marked=12
lam0=0.35
sigma=0.50
K=10 #number of occasions
buff=3 #state space buffer
X<- expand.grid(3:11,3:11) #make a trapping array
pMarkID=c(.8,.8)#probability of observing marked status of marked and unmarked individuals
pID=.8 #Probability marked individuals are identified
ncat=3  #number of ID categories
gamma=IDcovs=vector("list",ncat) #population frequencies of each category level. Assume equal here.
nlevels=rep(2,ncat) #number of levels per IDcovs
for(i in 1:ncat){
  gamma[[i]]=rep(1/nlevels[i],nlevels[i])
  IDcovs[[i]]=1:nlevels[i]
}
pIDcat=rep(1,ncat)#category observation probabilities
tlocs=0 #telemetry locs/marked individual
obstype="poisson" #observation model, count or presence/absence?
marktype="premarked" #premarked or natural ID (marked individuals must be captured)?
data=sim.conCatSMR(N=N,n.marked=n.marked,lam0=lam0,sigma=sigma,K=K,X=X,buff=buff,obstype=obstype,ncat=ncat,
                      pIDcat=pIDcat,gamma=gamma,IDcovs=IDcovs,pMarkID=pMarkID,tlocs=tlocs,pID=pID,marktype=marktype)
#MCMC
inits=list(lam0=lam0,sigma=sigma,gamma=gamma,psi=0.5) #start at simulated values
proppars=list(lam0=0.1,sigma=0.08,s=0.5,st=0.08) #st only for telemetered inds. Should be smaller than s.
M=150
storeLatent=TRUE
storeGamma=FALSE
niter=1000
nburn=0
nthin=1
IDup="Gibbs"
out=mcmc.conCatSMR(data,niter=niter,nburn=nburn, nthin=nthin, M = M, inits=inits,obstype=obstype,
                      proppars=proppars,storeLatent=TRUE,storeGamma=TRUE,IDup=IDup)


plot(mcmc(out$out))

1-rejectionRate(mcmc(out$out)) #shoot for 0.2 - 0.4 for lam0 and sigma. If too low, raise proppar. If too high, lower proppar.
1-rejectionRate(mcmc(out$sxout)) #activity center acceptance in x dimension. Shoot for min of 0.2
sum(rowSums(data$y.sight[(n.marked+1):N,,])>0) #true number of n.um

#Example of regular conventional SMR (no identity covariates)
library(coda)
N=50
n.marked=12
lam0=0.35
sigma=0.50
K=10 #number of occasions
buff=3 #state space buffer
X<- expand.grid(3:11,3:11) #make a trapping array
pMarkID=c(.8,.8)#probability of observing marked status of marked and unmarked individuals
pID=.8 #Probability marked individuals are identified
ncat=1  #number of ID categories
gamma=IDcovs=vector("list",ncat) #population frequencies of each category level. Assume equal here.
nlevels=rep(1,ncat) #number of levels per IDcovs
for(i in 1:ncat){
  gamma[[i]]=rep(1/nlevels[i],nlevels[i])
  IDcovs[[i]]=1:nlevels[i]
}
pIDcat=rep(1,ncat)#category observation probabilities
tlocs=0 #telemetry locs/marked individual
obstype="poisson" #observation model, count or presence/absence?
marktype="premarked" #premarked or natural ID (marked individuals must be captured)?
data=sim.conCatSMR(N=N,n.marked=n.marked,lam0=lam0,sigma=sigma,K=K,X=X,buff=buff,obstype=obstype,ncat=ncat,
                      pIDcat=pIDcat,gamma=gamma,IDcovs=IDcovs,pMarkID=pMarkID,tlocs=tlocs,pID=pID,marktype=marktype)
#MCMC
inits=list(lam0=lam0,sigma=sigma,gamma=gamma,psi=0.5) #start at simulated values
proppars=list(lam0=0.1,sigma=0.08,s=0.5,st=0.08) #st only for telemetered inds. Should be smaller than s.
M=150
storeLatent=TRUE
storeGamma=FALSE
niter=1000
nburn=0
nthin=1
IDup="Gibbs"
out=mcmc.conCatSMR(data,niter=niter,nburn=nburn, nthin=nthin, M = M, inits=inits,obstype=obstype,
                      proppars=proppars,storeLatent=TRUE,storeGamma=TRUE,IDup=IDup)


plot(mcmc(out$out))


}
}
\author{
Ben Augustine
}
